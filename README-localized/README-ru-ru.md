# Содержание
- [Содержание](#table-of-contents)
- [Intune-PowerShell-SDK-Code-Generator](#intune-powershell-sdk-code-generator)
- [Участие](#contributing)
- [Проектирование](#design)
    - [Высокоуровневая архитектура](#high-level-architecture)
    - [Шаг автоматического создания](#the-auto-generation-step)
- [Будущие задачи](#future-work)
- [Вопросы и ответы](#faq)
    - [Где создается код?](#where-is-the-generated-code)
    - [Зачем нам нужен этот модуль PowerShell?](#why-do-we-need-this-powershell-module)
    - [Почему мы хотим автоматически генерировать модуль PowerShell?](#why-do-we-want-to-auto-generate-the-powershell-module)
    - [Почему Intune создает его (и почему это не создает команда Graph SDK)?](#why-is-intune-building-it-and-why-isnt-the-graph-sdk-team-building-it)
    - [Что такое Vipr?](#what-is-vipr)
    - [Почему автор на заказ?](#why-a-custom-writer)
    - [Почему не использовать OpenAPI и Swagger?](#why-not-use-openapi-and-swagger)

# Intune-PowerShell-SDK-Code-Generator
В этом репозитории реализован модуль записи Vipr, который генерирует командлеты PowerShell для всех операций, функций и действий CRUD для поддержки Microsoft Intune Graph Api.

# Участие
Мы всегда рады предложениям и помощи в работе над проектом.
Обычно для добавления своих вариантов необходимо принять Лицензионное соглашение с участником (CLA), заявив, что вы имеете право предоставлять и предоставляете нам права на использование своего варианта.
Подробности см. на сайте https://cla.microsoft.com.

Когда вы будете отправлять запрос на вытягивание, CLA-бот автоматически определит, нужно ли вам предоставить CLA и соответствующим образом изменит внешний вид запроса на вытягивание (например, добавит метку, комментарий).
Просто следуйте инструкциям бота.
Это нужно будет сделать всего один раз для добавления своих вариантов во все репозитории, использующие наш CLA.

Этот проект соответствует [Правилам поведения разработчиков открытого кода Майкрософт](https://opensource.microsoft.com/codeofconduct/).
Дополнительные сведения см. в разделе [часто задаваемых вопросов о правилах поведения](https://opensource.microsoft.com/codeofconduct/faq/).
Если у вас возникли вопросы или замечания, напишите нам по адресу [opencode@microsoft.com](mailto:opencode@microsoft.com).

# Проектирование
## Высокоуровневая архитектура
![Архитектура высокого уровня](Design.jpg)
Это обзор того, как модуль PowerShell собран вместе.
1. Vipr.exe запускается со следующими аргументами для генерации кода, который определяет поведение командлетов. - Результат сборки проекта GraphODataPowerShellWriter (то есть GraphODataPowerShellWriter.dll).
- Схема Graph (например, результат вызова https://graph.microsoft.com/v1.0/$metadata)
- этот файл имеет расширение «.csdl» и находится в «~ / TestGraphSchemas».
2. Документация, которая была сгенерирована в выходных данных Vipr, извлекается в файл XML. Этот XML-файл используется PowerShell для отображения выходных данных командлета Get-Help.
3. Некоторые функции имеют смысл писать вручную в PowerShell, поэтому эти командлеты пишутся в своих собственных модулях. Эти модули находятся в "~/src/PowerShellGraphSDK/PowerShellModuleAdditions/CustomModules".
4. Выходные данные предыдущих 3 шагов (то есть сгенерированные командлеты, документация по командлетам и рукописные командлеты) объединяются с помощью файла манифеста PowerShell. Этот файл имеет расширение ".psd1".
5. Файл манифеста PowerShell, созданный на предыдущем шаге, затем используется для импорта и использования модуля. Например, если файл манифеста назывался «Intune.psd1», вы можете в окне PowerShell запустить «Import-Module ./Intune.psd1», чтобы импортировать модуль.

## Шаг автоматического создания
![Генерация двоичного модуля PowerShell](Generating_the_PowerShell_Binary_Module.jpg)
Подробно рассмотрим шаг 1 в разделе [Архитектура высокого уровня](#high-level-architecture).
- Файл определения схемы (CSDL) подается в Vipr.
- Читатель OData v4, который встроен в Vipr, используется для чтения файла CSDL. Этот читатель преобразует определение схемы в промежуточное представление, называемое моделью ODCM.
- Наш пользовательский писатель передается в Vipr для обработки этой модели ODCM. Модуль записи состоит из 4 шагов для преобразования модели ODCM в окончательно сгенерированные файлы C #:
1. Пройдите модель ODCM (то есть схему), чтобы обнаружить каждый маршрут.
2. Для каждого маршрута создайте абстрактное представление командлетов, представляющих каждую операцию на маршруте.
3. Преобразуйте каждое абстрактное представление командлета в абстрактное представление C #.
4. Для каждого абстрактного представления C # преобразуйте его в строку, которая будет записана как содержимое файла.

# Будущие задачи
- [ ] Улучшение именования сгенерированных командлетов.
    - [ ] Посмотрим, сможем ли мы добавить аннотации к схеме Graph, которые можно использовать для создания понятных имен для маршрутов.
- [ ] Найдите способ генерировать и создавать командлеты для всей схемы Graph за разумное время.
    - Количество маршрутов (из-за свойств навигации) резко увеличивается после включения объектов AAD.
- [ ] Получите сгенерированную справочную документацию по командлетам, чтобы включить ссылку на соответствующую страницу в официальной документации Graph.
- [x] Реализация передачи выходных данных командлета непосредственно в другие командлеты.
- [ ] Реализовать неинтерактивную аутентификацию.
    - [ ] Аутентификация с сертификатами.
    - [x] Аутентификация с PSCredential объектом.
- [x] Убедитесь, что мы получили правильное время истечения аутентификационного токена - это обрабатывается автоматическим обновлением токена при необходимости.
- [x] Создайте отдельный репозиторий для командлетов сценария (для использования в качестве подмодуля).
- [ ] Трэвис CI GitHub интеграция + контрольные примеры.
- [x] Создайте файл лицензии для используемого нами программного обеспечения сторонних производителей и включите его в модуль.
- [x] Обновите файл * .psd1, добавив в него правильные ссылки на общедоступный GitHub, файл лицензии и значок.
- [x] Создайте вспомогательные командлеты, которые создают объекты, которые можно сериализовать в типы, определенные в схеме.
- [] Получить ограничения возможностей OData, добавленные в схему Graph, чтобы командлеты, выполняющие запрещенные операции, не создавались в первую очередь.

# Вопросы и ответы
## Где создается код?
GitHub: https://github.com/Microsoft/Intune-PowerShell-SDK

## Зачем нам нужен этот модуль PowerShell?
Клиенты проявили большой интерес к использованию PowerShell для автоматизации задач, которые в настоящее время выполняются с помощью расширения Intune на портале Azure.

## Почему мы хотим автоматически генерировать модуль PowerShell?
Если мы пишем каждый командлет вручную, нам нужно будет вручную обновлять модуль каждый раз, когда обновляется схема Graph.

## Почему Intune создает его (и почему это не создает команда Graph SDK)?
Большинство пользователей Intune (ИТ-специалисты) предпочитают работать с PowerShell, тогда как Graph SDK ориентирован на разработчиков, которые предпочли бы работать, например, с. C #, Java и Python. Вот почему нам это нужно срочно. Структура синтаксиса PowerShell не поддается структуре существующего генератора SDK .Net / Java / Python (см. Объяснение, почему у нас есть [Custom Vipr Writer](#why-a-custom-writer)).

## Что такое Vipr?
- Архитектура построена вокруг проекта Microsoft Research под названием Vipr.
- Обобщает концепцию преобразования информации из одного синтаксиса в другой.
- По сути, это модульный анализатор текста, который особенно хорошо подходит для определений сервисов в стиле OData.
- Исполняемый файл принимает сборку Reader и Writer.
    - Reader может анализировать входной текстовый файл в промежуточное (универсальное) представление Vipr.
    - Writer принимает это промежуточное представление и возвращает список файловых объектов, то есть пар (строка, путь).
        - Затем Vipr записывает эти файлы в заданной структуре папок в выходную папку.

## Почему автор на заказ?
Для Vipr нет доступных средств записи PowerShell. Кроме того, писатель .Net/Java/Python Graph SDK's не может легко приспособиться к синтаксису, поведению и лучшим методикам PowerShell.

## Почему не использовать OpenAPI и Swagger?
Это было бы возможно, но потребовало бы дополнительного преобразования из схемы OData Graph в формат OpenAPI. С каждым преобразованием возникает риск потери информации, которая может быть полезна в сгенерированном модуле PowerShell.